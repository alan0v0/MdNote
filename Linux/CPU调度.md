# Linux CPU调度
[知乎-万字长文揭秘Linux进程调度器](https://zhuanlan.zhihu.com/p/486275661)

> 介绍CPU调度器设计目标、有关调度概念、算法设计、工程实现、linux cfs基本特点 、运行机理

[极客时间-Linux如何实现进程与进程调度](https://time.geekbang.org/column/article/393350)

> 详细介绍Linux调度实体组织方式，cfs 调度器工作原理及代码实现

[Linux核心概念详解](https://s3.shizhz.me/linux-sched/cfs-sched/group)

> 调度时机、调度组、 smp多核负载均衡 等概念



进程/任务分类：

1. IO密集型，交互型，特点是重IO，会频繁发起IO类系统调用被挂起，被唤醒后最好能尽快被分配cpu时间。低延迟带来更好用户体验

2. cpu密集型，主要是大量、复杂的数学运算，主要依赖CPU算力完成任务

理想状态下，调度器要让 IO密集型进程被优先调度，它们对IO进行响应后会很快再次挂起，用户层面会感受到系统流畅，不卡顿。然后在调度cpu密集型进程。但是现实情况是，调度器无法 预先知道进程属性，无法立刻予于其最合适的调度策略。大部分调度器，通过持续观察进程行为对其进行打分，不断调整其调度优先级和可用CPU时间。

### cfs调度器 complete fair scheduler

cfs 一个调度周期时间不是固定的，根据等待调度的进程总数来决定。调度器必须保证一个调度周期内，任何一个进程都会被调度一次（最小时间粒时0.74ms，确保进程有运行一段时间，并且避免频繁进行调度，导致用户进程实际CPU利用率太低），避免出现进程饥饿。

cfs 根据进行进程nice值换算出进程权重，nice值越低权重越高。进程在调度周期获取的

`进程cpu时间比例= 本进程权重/所有进程权重*调度周期 `

cfs 提出虚拟调度时间概念，virtualtime，并且只保证周期内每个进程虚拟时间是相等的。每次需要调度时 选取当前虚拟时间最短的进程进行调度。

`vtime= 已获取的cpu时间*（nice_0_权重/进程权重）`

可以看到进程权重越大，进程虚拟时间涨得越慢，在调度周期的实际CPU时间越长。结合上面两个公式可以发现，进程vtime 和本身权重无任何关系 实现了“公平”。

内核时钟周期中断会 计算更新当前获取CPU时间进程 的已获取cpu时长，已经其他 cfs_rq 统计量 

当有进程被唤醒、进程运行时长超vtime时，调度器会进行一次调度，重新决定可运行进程

### 仍存在的困惑？

cfs未尝试区分 io型、cpu型进程 ，只根据权重决定每个进程cpu运行时长，且权重似乎是静态写死的，这样是否合理，没有 调度优先级的概念，没有考虑优先调度IO型任务

**cfs 确实已经抛弃猜测进程属性**